<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Liu Xuejun&#39;s Blog</title>
<meta name="description" content="念念不忘，必有回响" />
<link rel="shortcut icon" href="https://liuxuejun123.github.io//favicon.ico?v=1619259101705">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://liuxuejun123.github.io//styles/main.css">
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>


  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://liuxuejun123.github.io/">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://liuxuejun123.github.io//images/avatar.png?v=1619259101705" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">Liu Xuejun&#39;s Blog</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1introduction-to-tim">1.Introduction to TIM</a>
<ul>
<li><a href="#11-clock-source-selection-register-timx_smcr">1.1 Clock source selection register (TIMx_SMCR)</a></li>
<li><a href="#12-prescaler-register-timx_psc">1.2 Prescaler register (TIMx_PSC)</a></li>
<li><a href="#13-timer-count-register-timx_cnt">1.3 Timer count register (TIMx_CNT)</a></li>
<li><a href="#14-automatic-reload-register-timx_arr">1.4 Automatic reload register (TIMx_ARR)</a></li>
<li><a href="#15-dma-interrupt-enable-register-timx_dier">1.5 DMA / Interrupt Enable Register (TIMx_DIER)</a></li>
<li><a href="#16-control-register-1-timx_cr1">1.6 Control Register 1 (TIMx_CR1)</a></li>
<li><a href="#17-status-register-timx_sr">1.7 Status register (TIMx_SR)</a></li>
</ul>
</li>
<li><a href="#code">Code</a>
<ul>
<li><a href="#simulation">Simulation</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="\achieve" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by 
<a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
<br><br>
Copyright 2020 &copy 
<a href="https://twitter.com/mei_samson" target="_blank">
<span style="color:blue">Liuxuejun</span></a>
<br><br>
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="blank"
<span style="color:orange">本博客采用 CC BY-NC-SA 4.0 进行许可</span></a></div>
    <a class="rss" href="https://liuxuejun123.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">STM 32 定时器的使用</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-04-29 / 8 min read
        </div>
        
        <div class="post-content yue">
          <p>In Proteus in an existing project, remove virtual terminal, add COMPIM (COM port Physical interface model) and connect it to the microcontroller. In COMPIM set correct real physical port and baudrates.<br>
Devices in project:<br>
• Microcontroller;<br>
• 2 LEDs;<br>
• Button;<br>
• COMPIM.<br>
In Keil, supplement the project for the microcontroller. Setup 2 timers with interrupt on update, one for reading states of button, second for periodic send data to other device (program in out case).<br>
Parts of task:</p>
<ol>
<li>Setup first timer with interrupt on update. In interrupt read state of button and change LEDs state depend on button.</li>
<li>Setup second timer with interrupt on update. It must be 100 interrupts is 1 second. In the interrupt handler increase some variables and call USART send function for send array (one item of the array must be increased variable).<br>
For receive data from microcontroller use Simulink model, and show received data in scope.</li>
</ol>
<p>This experiment is mainly to learn the timer configuration using stm32.</p>
<h2 id="1introduction-to-tim">1.Introduction to TIM</h2>
<p>Among them the basic timer includes TIM6, TIM7, its structure is the simplest, also has the most basic timing function, one is for basic timing, generating time base, and the other is for driving DAC digital-to-analog converter. Among them, there are 10 general-purpose timers including TIME2-TIME5 and TIME9-TIME14. In addition to the functions of the basic timer, the general-purpose timer also has input capture, output comparison, and PWM functions. he advanced timers include TIM1, TIM8; The related common register functions of the timer are as follows:</p>
<h3 id="11-clock-source-selection-register-timx_smcr">1.1 Clock source selection register (TIMx_SMCR)</h3>
<p>There are 4 clock sources for the timer:<br>
-Internal clock (CK_INT)<br>
-External clock mode 1: External input pin (TIx)<br>
-External clock mode 2: External trigger input (ETR), only applicable to TIM2, TIM3, TIM4<br>
-Internal trigger input (ITRx): Make A timer to be prescaler of B timer (A provides clock for B)<br>
This is selected by setting the relevant bit of TIMx_SMCR. The internal clock (CK_INT) comes from the APB1 or APB2 bus</p>
<h3 id="12-prescaler-register-timx_psc">1.2 Prescaler register (TIMx_PSC)</h3>
<p>This register is used to divide the clock and then provide it to the counter as the clock of the counter.</p>
<figure data-type="image" tabindex="1"><img src="https://liuxuejun123.github.io//post-images/1588173281702.PNG" alt="" loading="lazy"></figure>
<p>The 16-bit space stores the frequency division coefficient.</p>
<h3 id="13-timer-count-register-timx_cnt">1.3 Timer count register (TIMx_CNT)</h3>
<p>It stores the current count value of the timer.</p>
<h3 id="14-automatic-reload-register-timx_arr">1.4 Automatic reload register (TIMx_ARR)</h3>
<figure data-type="image" tabindex="2"><img src="https://liuxuejun123.github.io//post-images/1588173385400.PNG" alt="" loading="lazy"></figure>
<p>This register corresponds to two registers in the physical structure, one can be operated by the programmer, and the other is invisible and inoperable ARM called it as the shadow register. The shadow registers are actually in effect.<br>
According to the setting of the APRE bit in the TIMx_CR1 register: when APRE = 0, the contents of the preload register can be transferred to the shadow register at any time, and the two are connected at this time; and when APRE = 1, at each update event (UEV) Before the contents of the preload register (ARR) are transferred to the shadow register.</p>
<h3 id="15-dma-interrupt-enable-register-timx_dier">1.5 DMA / Interrupt Enable Register (TIMx_DIER)</h3>
<figure data-type="image" tabindex="3"><img src="https://liuxuejun123.github.io//post-images/1588173450494.PNG" alt="" loading="lazy"></figure>
<p>Here we only use the last bit: update interrupt enable (UIE: update interrupt enable), set to 1 instead to allow interrupts caused by update events</p>
<h3 id="16-control-register-1-timx_cr1">1.6 Control Register 1 (TIMx_CR1)</h3>
<figure data-type="image" tabindex="4"><img src="https://liuxuejun123.github.io//post-images/1588173463731.PNG" alt="" loading="lazy"></figure>
<p>We only need to use the last bit: the counter enable bit (CEN: counter enable), instead it must be set to 1 to enable the counter to start counting.</p>
<h3 id="17-status-register-timx_sr">1.7 Status register (TIMx_SR)</h3>
<p><img src="https://liuxuejun123.github.io//post-images/1588173472820.PNG" alt="" loading="lazy">![]</p>
<p>This register is used to mark whether various events / interrupts related to the current timer have occurred</p>
<h2 id="code">Code</h2>
<pre><code class="language-c">#include &quot;stm32f4xx.h&quot;
#include &quot;stm32f4xx_hal_gpio.h&quot;
#include &quot;stm32f4xx_hal_rcc.h&quot;
#include &lt;math.h&gt;
//define Internal RC frequencies
#define XTAL 16000000UL

//define busses prescalers
#define AHB_PRE 1
#define APB1_PRE 2
#define APB2_PRE 1
#define SysTickClk 10000

//calculate peripheral frequencies
#define SYSCLK 84000000
#define AHB SYSCLK/AHB_PRE
#define APB1 AHB/APB1_PRE
#define APB1_TIM APB1*2
#define APB2 AHB/APB2_PRE
#define APB2_TIM APB2*1
#define SysTicks AHB/SysTickClk

//usart
#define USART_BAUDRATE 19200
#define BUFFER_LENGTH 3
uint16_t buffer_size=0,current_send_byte;
uint8_t buffer[BUFFER_LENGTH];
//math
#define M_pi 3.1415926535897323846

void clock_set()
{
FLASH-&gt;ACR|=FLASH_ACR_PRFTEN;
FLASH-&gt;ACR|=FLASH_ACR_LATENCY_2WS;//FLASH PREFETCH
RCC-&gt;CFGR&amp;=~RCC_CFGR_HPRE_Msk;
RCC-&gt;CFGR|=RCC_CFGR_HPRE_DIV1;
RCC-&gt;CFGR&amp;=~RCC_CFGR_PPRE1_Msk;
RCC-&gt;CFGR|=RCC_CFGR_PPRE1_DIV2;
RCC-&gt;CFGR&amp;=~RCC_CFGR_PPRE2_Msk;
RCC-&gt;CFGR|=RCC_CFGR_PPRE2_DIV1;//set AHB APB1 APB2
RCC-&gt;PLLCFGR&amp;=~RCC_PLLCFGR_PLLM_Msk;
RCC-&gt;PLLCFGR|=8&lt;&lt;RCC_PLLCFGR_PLLM_Pos;
RCC-&gt;PLLCFGR&amp;=~RCC_PLLCFGR_PLLN_Msk;
RCC-&gt;PLLCFGR|=84&lt;&lt;RCC_PLLCFGR_PLLN_Pos;
RCC-&gt;PLLCFGR&amp;=~RCC_PLLCFGR_PLLP_Msk; //SET PLLM PLLN PLLP
RCC-&gt;CR|=RCC_CR_PLLON;//OPEN PLL
while((RCC-&gt;CR&amp;RCC_CR_PLLRDY)==0)//WAIT PLL START
{}
RCC-&gt;CFGR&amp;=(uint32_t)((uint32_t)~(RCC_CFGR_SW));
RCC-&gt;CFGR|=RCC_CFGR_SW_PLL;
while((RCC-&gt;CFGR&amp;RCC_CFGR_SWS)!=RCC_CFGR_SWS_PLL)
{}
}

void usart2_Init(uint32_t baud)
{
RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOAEN|
	              RCC_AHB1ENR_GPIOBEN;//open clock
GPIOA-&gt;MODER =0x000000A0;//pa2 pa3 	Multiple function mode
GPIOA-&gt;AFR[0]=0x00007700;//
GPIOB-&gt;MODER=0x00005555;//GPIOB
RCC-&gt;APB1ENR |= RCC_APB1ENR_USART2EN;//usart2 enable
USART2-&gt;BRR = APB1/baud;//Baudrate
USART2-&gt;CR1 = USART_CR1_UE|//usart2enable
	            USART_CR1_TE|//
	            USART_CR1_RE|//transmit receive enable
	            USART_CR1_RXNEIE;//Interrupt enable
NVIC_EnableIRQ(USART2_IRQn);//Configuration interrupt	
}

void SendByte(uint8_t dat)
{
	USART2-&gt;DR = dat;
	while((USART2-&gt;SR &amp; USART_SR_TC) == 0);
}

void Send_buffer(uint8_t *buff,uint16_t count)
{
for (int i=0;i&lt;count;i++)
	{
		SendByte(*buff);
		*buff++;
	}
}

void delay_ms(uint16_t time)     
{    
  uint16_t i=0;    
  while(time--)     
  {    
    i=12000;    
    while(i--);    
  }    
}
void USART2_IRQHandler(void)
{
	if(USART2-&gt;SR &amp; USART_SR_RXNE)
	{
		buffer[buffer_size] = USART2-&gt;DR;
		buffer_size++;
		if(buffer[buffer_size-1] == 'k')
		{
			GPIOB-&gt;ODR &amp;= ~(1 &lt;&lt;0); //LEN0 OFF
			buffer_size = 0;
			USART2-&gt;CR1 &amp;= ~USART_CR1_RE;
		}
		else if(USART2-&gt;DR == 'l')
		{
			GPIOB-&gt;ODR |= 1 &lt;&lt; 0; // LED0 ON
			buffer_size = 0;
			USART2-&gt;CR1 &amp;= ~USART_CR1_RE;
		}
	}
}
void TIM1_BRK_TIM9_IRQHandler(void)
{
TIM9-&gt;SR &amp;=~TIM_SR_UIF;
	if(!(GPIOB-&gt;IDR &amp; GPIO_IDR_ID9))
	{
	GPIOB-&gt;BSRR |= GPIO_BSRR_BS1;
	GPIOB-&gt;BSRR |= GPIO_BSRR_BR0;
	}
	else
	{
	GPIOB-&gt;BSRR |= GPIO_BSRR_BS0;
	GPIOB-&gt;BSRR |= GPIO_BSRR_BR1;
	}
}
void TIM1_UP_TIM10_IRQHandler(void)
{
  TIM10-&gt;SR &amp;=~TIM_SR_UIF;
	static uint8_t i=0;
	if(++i==100) i=0;
	double s=sin(i*2*M_pi/100);
	buffer[0]='A';
	buffer[1]=i;
	buffer[2]=(int8_t)(s*100);
	if(1)
	{
	Send_buffer(buffer,3);
	}
}
void Init_tim9(uint16_t arr,uint16_t psc)
{
	//OPEN TIM9
	RCC-&gt;APB2ENR |=1&lt;&lt;16;
	TIM9-&gt;CNT=0;//CLEAR 
	TIM9-&gt;PSC = psc;
	TIM9-&gt;ARR = arr;
/*Allow update interrupt enable*/
	TIM9-&gt;DIER |= 1&lt;&lt;0;
/*Enable basic timer interrupt*/
  NVIC_EnableIRQ(TIM1_BRK_TIM9_IRQn);
/*Turn on counter enable*/
  TIM9-&gt;CR1 |= 1&lt;&lt;0;
}
void Init_tim10(uint16_t arr,uint16_t psc)
{
	//OPEN TIM10
	RCC-&gt;APB2ENR |=1&lt;&lt;17;
	TIM10-&gt;CNT=0;//CLEAR 
	TIM10-&gt;PSC = psc;
	TIM10-&gt;ARR = arr;
/*Allow update interrupt enable*/
	TIM10-&gt;DIER |= 1&lt;&lt;0;
/*Enable basic timer interrupt*/
  NVIC_EnableIRQ(TIM1_UP_TIM10_IRQn);
/*Turn on counter enable*/
  TIM10-&gt;CR1 |= 1&lt;&lt;0;
}

int main()
{
	clock_set();
	usart2_Init(USART_BAUDRATE);
	Init_tim9(1000,84-1);//fre=84000000/84/1000    1000hz
	Init_tim10(10000,84-1);//fre=84000000/84/10000 100hz
while(1)
{}
}
</code></pre>
<h3 id="simulation">Simulation</h3>
<figure data-type="image" tabindex="5"><img src="https://liuxuejun123.github.io//post-images/1588173500577.PNG" alt="" loading="lazy"></figure>
<p>Press the switch to change the LED on and off</p>
<figure data-type="image" tabindex="6"><img src="https://liuxuejun123.github.io//post-images/1588173644598.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://liuxuejun123.github.io//post-images/1588173757806.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://liuxuejun123.github.io//post-images/1588173788729.PNG" alt="" loading="lazy"></figure>
<h2 id="conclusion">Conclusion</h2>
<p>Through this experiment, I learned the configuration of timers and the use of timer interrupts. And use Matlab simulink to observe the simulation situation through the virtual serial port. During the experiment, I also encountered some problems. Finding information through the Internet made me clearer about the whole process.</p>

        </div>

        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://liuxuejun123.github.io/post/stm32-h-qiao-qu-dong-dian-ji-chuan-kou-kong-zhi-jie-shou-matlabproteus-lian-he-diao-shi/">
                <h3 class="post-title">
                  <i class="ri-arrow-left-line"></i>
                  STM32 H桥驱动电机，串口控制接收，Matlab+Proteus 联合调试
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://liuxuejun123.github.io/post/stm32f401re-pwm-shu-chu/">
                <h3 class="post-title">
                  STM32F401RE PWM输出
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>
			<div id="vcomments"></div>
			<script>
			new Valine({
			el: '#vcomments',
			appId: '7PkqecRcjgS1uaF60SMWxDMH-gzGzoHsz',
			appKey: 'Vb5bQCHJavyHDCk3mor2nHkj'
			})
			</script>
        

      </div>
    </div>

    <script src="https://liuxuejun123.github.io//media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
