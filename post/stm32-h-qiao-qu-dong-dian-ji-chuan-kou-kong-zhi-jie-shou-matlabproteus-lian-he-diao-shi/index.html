
<!DOCTYPE html>
<html lang="zh-CN">
<head>
 <meta name="viewport" content="width=device-width, initial-scale=1" />
<meta HTTP-EQUIV="pragma" CONTENT="no-cache"> 
<meta HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate"> 
<meta HTTP-EQUIV="expires" CONTENT="0"> 
<title>STM32 H桥驱动电机，串口控制接收，Matlab+Proteus 联合调试 | Liu Xuejun&#39;s Blog</title>	

<link rel="stylesheet" href="https://liuxuejun123.github.io//styles/main.css">
<script type="text/javascript">
function getCSS()
{
        datetoday = new Date();
        timenow=datetoday.getTime();
        datetoday.setTime(timenow);
        thehour = datetoday.getHours();

        if (thehour<6)

            display = "https://liuxuejun123.github.io//media/css/night.css";

       else if (thehour>20)

            display = "https://liuxuejun123.github.io//media/css/night.css";   

        else if (thehour>6)
           
            display = "https://liuxuejun123.github.io//media/css/day.css";

        else if (thehour<20)

            display = "https://liuxuejun123.github.io//media/css/day.css";
      

var css = '<';
        css+='link rel="stylesheet" href='+display+' \/';
        css+='>';
        document.write(css);
}
</script>
<link href="https://fonts.googleapis.com/css?family=Dancing+Script|Liu+Jian+Mao+Cao&display=swap" rel="stylesheet">
<link href="https://at.alicdn.com/t/font_1306644_jwtuc2zzbrd.css" rel="stylesheet" />
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<script type='text/javascript' src='https://liuxuejun123.github.io//media/scripts/script.js'></script>
<link href="https://cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet" />
  <script src="https://cdn.bootcss.com/wow/1.1.2/wow.min.js"></script>
  <script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>wow=new WOW({boxClass:'wow',animateClass:'animated',offset:0,mobile:true,live:true});wow.init();</script>

<script type="text/javascript">
window.onload=getCSS();
</script>


 	
</head>
<body class="post-template-default single single-post postid-70 single-format-standard">
    <div id="wrapper">
        
			
		<header id="header" class="site-header" 
		
		>
			<div class="site-branding">
									<h1 class="site-title"><a href="https://liuxuejun123.github.io/" rel="home">Liu Xuejun&#39;s Blog</a></h1>
										
					<h2 class="site-description">念念不忘，必有回响</h2>
										
							</div>
			<nav id="nav-wrapper">
				<div class="container">
					<div class="nav-toggle">
						<div class="bars">
							<div class="bar"></div>
							<div class="bar"></div>
							<div class="bar"></div>
						</div>
					</div>
					<div class="clear"></div>
					<ul id="" class="dove">
		 
     			
<li>
	 
	<a  href="/"> 首页</a></li>
	
    
     			
<li>
	 
	<a  href="/archives"> 归档</a></li>
	
    
     			
<li>
	 
	<a  href="/tags"> 标签</a></li>
	
    
     			
<li>
	 
	<a  href="/post/about"> 关于</a></li>
	
    

</ul>
</li>		
		
</ul>				</div>
			</nav>
						<div class="jingge">


    

    

    

    

    

    

    

    

    

    

    

    
        </header>

		<div id="content" class="container">
			<div class="row">
	<div class="col-md-8 site-main">
				
<article id="post-70" class="post-70 post type-post status-publish format-standard hentry category-5 tag-10 tag-9 tag-11">

	
	                      
		<div class="entry-content">
			<h1 class="wow swing entry-title">STM32 H桥驱动电机，串口控制接收，Matlab+Proteus 联合调试</h1>
<div class="entry-meta">
<div class="wow bounce">
	<i class="iconfont icon-rili"> <time class="lately-a" datetime="2020-04-29 23:23:49" itemprop="datePublished" pubdate="">2020-04-29</time></i>
	          </div>
			
</span>
													 
		</div>
                  
			<div class="wow slideInLeft entry-summary song">
				<figure data-type="image" tabindex="1"><img src="https://liuxuejun123.github.io//post-images/1588173952599.PNG" alt="" loading="lazy"></figure>
<h2 id="problem-description">Problem Description</h2>
<ol>
<li>Create motor control system<br>
a. Setup first timer. It must have 2 output PWM lines for control motor speed of motion.<br>
b. In Simulink add Serial send block. For set speed of motion (PWM period %) use slider gain (with values from -100 to 100).<br>
c. On reading byte from Simulink set control signals for motor.</li>
<li>Setup second timer. It must have 2 input line from encoder.</li>
<li>Counted pulses from encoder send to Simulink.<br>
For receive data from microcontroller use Simulink model, and show received data in scope.</li>
</ol>
<h2 id="task-analysis">Task analysis</h2>
<p>After analyzing the entire task, the main solution：</p>
<p>Enable TIM3 PWM output mode Configure channel 1 (PA6), channel 2 (PA7), and control the high and low levels of PA5 and PA6. Matlab sends a number of -100-100 to indicate the direction and speed of the motor. After the serial port receives the data, it controls the motor after the data is processed, and then processes the encoded signal output by the motor through the TIM4 encoding function to obtain the speed of the motor, and Resend to Matlab via serial communication</p>
<h2 id="tim-pwm-mode-and-configuration-method">Tim PWM mode and configuration method</h2>
<p><img src="https://liuxuejun123.github.io//post-images/1588173937637.png" alt="" loading="lazy"><br>
The general-purpose timer can use the GPIO pin for pulse output. When it is configured as a comparison output or a PWM output function, the capture / compare register TIMx_CCR is used as a comparison function, which is referred to as a comparison register below.<br>
Here is a direct example to illustrate the working process of the PWM output of the timer: if the pulse counter TIMx_CNT is configured to count up, and the reload register TIMx_ARR is configured to N, that is, the current count value X of the TIMx_CNT is continuously accumulated under the drive of the TIMxCLK clock source When the value X of TIMx_CNT is greater than N, the value of TIMx_CNT will be reset to 0 and counted again.<br>
While counting TIMxCNT, the count value X of TIMxCNT will be compared with the value A pre-stored in the comparison register TIMx_CCR. When the value X of the pulse counter TIMx_CNT is less than the value A of the comparison register TIMx_CCR, the high level (or low Level), conversely, when the value X of the pulse counter is greater than or equal to the value A of the comparison register, a low level (or high level) is output.<br>
In this way, the output pulse period is the value (N + 1) stored in the reload register TIMx_ARR multiplied by the clock period of the trigger pulse, and the pulse width is the value A of the comparison register TIMx_CCR multiplied by the clock period of the trigger pulse, that is The duty cycle of the output PWM is A / (N + 1).</p>
<h2 id="encoder-interface-mode">Encoder interface mode</h2>
<p><img src="https://liuxuejun123.github.io//post-images/1588173997249.PNG" alt="" loading="lazy"><br>
When both AB are the same, a square wave is output, and the phase difference is 90 °. We can judge the forward and reverse by judging the order of the level transition of the two phases of AB, and we can also determine the number of level transitions of any one phase. Rotation speed</p>
<h2 id="timx-capturecompare-mode-register-1-timx_ccmr1">TIMx capture/compare mode register 1 (TIMx_CCMR1)</h2>
<figure data-type="image" tabindex="2"><img src="https://liuxuejun123.github.io//post-images/1588174028343.PNG" alt="" loading="lazy"></figure>
<h4 id="bits-98-cc2s10-capturecompare-2-selection">Bits 9:8 CC2S[1:0]: Capture/Compare 2 selection</h4>
<p>This bit-field defines the direction of the channel (input/output) as well as the used input.<br>
00: CC2 channel is configured as output<br>
01: CC2 channel is configured as input, IC2 is mapped on TI2<br>
10: CC2 channel is configured as input, IC2 is mapped on TI1<br>
11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if<br>
an internal trigger input is selected through the TS bit (TIMx_SMCR register)<br>
Note: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).</p>
<h4 id="bits-10-cc1s-capturecompare-1-selection">Bits 1:0 CC1S: Capture/Compare 1 selection</h4>
<p>This bit-field defines the direction of the channel (input/output) as well as the used input.<br>
00: CC1 channel is configured as output.<br>
01: CC1 channel is configured as input, IC1 is mapped on TI1.<br>
10: CC1 channel is configured as input, IC1 is mapped on TI2.<br>
11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if<br>
an internal trigger input is selected through TS bit (TIMx_SMCR register)<br>
Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).</p>
<h2 id="timx-capturecompare-enable-register-timx_ccer">TIMx capture/compare enable register (TIMx_CCER)</h2>
<figure data-type="image" tabindex="3"><img src="https://liuxuejun123.github.io//post-images/1588174071967.PNG" alt="" loading="lazy"></figure>
<h4 id="bit-4-cc2e-capturecompare-2-output-enable">Bit 4 CC2E: Capture/Compare 2 output enable.</h4>
<p>refer to CC1E description</p>
<h4 id="bit-0-cc1e-capturecompare-1-output-enable">Bit 0 CC1E: Capture/Compare 1 output enable.</h4>
<p>CC1 channel configured as output:<br>
0: Off - OC1 is not active<br>
1: On - OC1 signal is output on the corresponding output pin<br>
CC1 channel configured as input:<br>
This bit determines if a capture of the counter value can actually be done into the input<br>
capture/compare register 1 (TIMx_CCR1) or not.<br>
0: Capture disabled<br>
1: Capture enabled</p>
<h2 id="code">Code</h2>
<pre><code class="language-c">#include &quot;stm32f4xx.h&quot;
#include &quot;stm32f4xx_hal_gpio.h&quot;
#include &quot;stm32f4xx_hal_rcc.h&quot;
#include &lt;math.h&gt;
//define Internal RC frequencies
#define XTAL 16000000UL

//define busses prescalers
#define AHB_PRE 1
#define APB1_PRE 2
#define APB2_PRE 1
#define SysTickClk 10000

//calculate peripheral frequencies
#define SYSCLK 84000000
#define AHB SYSCLK/AHB_PRE
#define APB1 AHB/APB1_PRE
#define APB1_TIM APB1*2
#define APB2 AHB/APB2_PRE
#define APB2_TIM APB2*1
#define SysTicks AHB/SysTickClk

//usart
#define USART_BAUDRATE 19200
#define BUFFER_LENGTH 100
uint16_t buffer_size=0,current_send_byte;
uint8_t buffer[BUFFER_LENGTH];
//math
#define M_pi 3.1415926535897323846
uint16_t T_pwm;
int8_t motor_speed;
uint8_t S[]={100,100,101};

/*******    Clock settings    ***********/
void clock_set()
{
FLASH-&gt;ACR|=FLASH_ACR_PRFTEN;
FLASH-&gt;ACR|=FLASH_ACR_LATENCY_2WS;//FLASH PREFETCH
RCC-&gt;CFGR&amp;=~RCC_CFGR_HPRE_Msk;
RCC-&gt;CFGR|=RCC_CFGR_HPRE_DIV1;
RCC-&gt;CFGR&amp;=~RCC_CFGR_PPRE1_Msk;
RCC-&gt;CFGR|=RCC_CFGR_PPRE1_DIV2;
RCC-&gt;CFGR&amp;=~RCC_CFGR_PPRE2_Msk;
RCC-&gt;CFGR|=RCC_CFGR_PPRE2_DIV1;//set AHB APB1 APB2
RCC-&gt;PLLCFGR&amp;=~RCC_PLLCFGR_PLLM_Msk;
RCC-&gt;PLLCFGR|=8&lt;&lt;RCC_PLLCFGR_PLLM_Pos;
RCC-&gt;PLLCFGR&amp;=~RCC_PLLCFGR_PLLN_Msk;
RCC-&gt;PLLCFGR|=84&lt;&lt;RCC_PLLCFGR_PLLN_Pos;
RCC-&gt;PLLCFGR&amp;=~RCC_PLLCFGR_PLLP_Msk; //SET PLLM PLLN PLLP
RCC-&gt;CR|=RCC_CR_PLLON;//OPEN PLL
while((RCC-&gt;CR&amp;RCC_CR_PLLRDY)==0)//WAIT PLL START
{}
RCC-&gt;CFGR&amp;=(uint32_t)((uint32_t)~(RCC_CFGR_SW));
RCC-&gt;CFGR|=RCC_CFGR_SW_PLL;
while((RCC-&gt;CFGR&amp;RCC_CFGR_SWS)!=RCC_CFGR_SWS_PLL)
{}
}

/****  Serial port initialization  ******/
/**** pa2 pa3 multiplexing function****/
void usart2_Init(uint32_t baud)
{
RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOAEN|
	              RCC_AHB1ENR_GPIOBEN;//open clock
GPIOA-&gt;MODER =0x000000A0;//Multiple function mode 	
GPIOA-&gt;AFR[0]=0x00007700;//
RCC-&gt;APB1ENR |= RCC_APB1ENR_USART2EN;//usart2 enable
USART2-&gt;BRR = APB1/baud;//Baud rate
USART2-&gt;CR1 = USART_CR1_UE|//usart2 enbale
	            USART_CR1_TE|//
	            USART_CR1_RE|//Send and receive enable
	            USART_CR1_RXNEIE;//Interrupt enable
NVIC_EnableIRQ(USART2_IRQn);//Configuration interrupt		
}

/**** delay function ****/
void delay_ms(uint16_t time)     
{    
  uint16_t i=0;    
  while(time--)     
  {    
    i=12000;    
    while(i--);    
  }    
}
/********* Motor control detection section *************/
//TIM4_Encoder_Init,Tim4_CH1(PB6);Tim4_CH2(PB7)

void TIM4_Encoder_Init(uint16_t arr,uint16_t psc)
{

 RCC-&gt;APB1ENR |= (4&lt;&lt;0);  //TIM4 clock enabled
 GPIOB-&gt;MODER |= 1 &lt;&lt; (6*2 + 1) | 1 &lt;&lt; (7*2 + 1); ; // Reuse output mode
 GPIOB-&gt;AFR[0] |= (uint32_t)0x22000000; // Reuse as TIM4	
 TIM4-&gt;ARR=arr;            
 TIM4-&gt;PSC=psc;  
	
 TIM4-&gt;CCMR1 &amp;= 0xFCFC;//clear 0
 TIM4-&gt;CCMR1 |= TIM_CCMR1_CC1S_0;//Capture/Compare 1 Selection
 TIM4-&gt;CCMR1 |= TIM_CCMR1_CC2S_0;

 TIM4-&gt;CCMR1 |= TIM_CCMR1_OC1M_0;//Output Compare 1 Mode
 TIM4-&gt;CCMR1 |= TIM_CCMR1_OC1M_1;
	
 TIM4-&gt;CCER |= TIM_CCER_CC1E; // Enable comparison output
 TIM4-&gt;CCER |= TIM_CCER_CC2E;
 
 TIM4-&gt;EGR |= TIM_EGR_UG;  //Update

 TIM4-&gt;SMCR &amp;= 0xFFF8;
 TIM4-&gt;SMCR |= TIM_SMCR_SMS_0;
 TIM4-&gt;SMCR |= TIM_SMCR_SMS_1;
 
 TIM4-&gt;CNT = 0;
 TIM4-&gt;CR1 |= TIM_CR1_CEN;  // Counter enable            
}


/********   TIM3 Two PWM output control speed *************/
void init_TIM3_PWM(uint16_t psc,uint16_t arr)//control pin 67 //psc arr fre set，ch1 ch2 Duty cycle
{
  SCB-&gt;AIRCR = 0x05FA0000 | 0x400;  //Interrupt priority group preemption: response = 3: 1
  GPIOA-&gt;MODER |= 0X0001A400;//pc67 second function 5 8 out
        
  GPIOA-&gt;OSPEEDR |= 0x0000f000;//speed 100m
  GPIOA-&gt;PUPDR |= 0x00005000;//up   
  GPIOA-&gt;AFR[0] |= 0x22000000;//pc67 second function AF2
  RCC-&gt;APB1ENR |= (1&lt;&lt;1); //open TIM3 clock
  TIM3-&gt;PSC = psc; //
  TIM3-&gt;ARR = arr;  //
  TIM3-&gt;EGR |= 1; //Generate an update event
  TIM3-&gt;CCMR1 |= 0x6060;//PWM mode 1
  TIM3-&gt;CCER |= 0x1111;//Enable comparison output
  TIM3-&gt;CCMR1 |= 0x0808;//Start preload
  TIM3-&gt;CR1 |= 1; //start
}

/********* Motor speed and reverse control function********/
void Motor_Speed_Control(int8_t motorSpeed)         
{
    int16_t speed = 0 ;        
        
       if(motorSpeed&gt;100)  speed = 100;
	else if (motorSpeed&lt;-100)  speed = -100;
     else  speed = motorSpeed;
        if(speed == 0)
        {
        GPIOA-&gt;ODR |=GPIO_ODR_OD5;//pa5 high level
				GPIOA-&gt;ODR |=GPIO_ODR_OD8;//Pa8 high level 
				TIM3-&gt;CCR1 = speed *0;//ch1 no output  
				TIM3-&gt;CCR2 = speed *0;//ch2 no output	
        }
            else if(speed &gt; 0)//Forward rotation, 
                {
									GPIOA-&gt;ODR |=GPIO_ODR_OD5;
									GPIOA-&gt;ODR &amp;=~(GPIO_ODR_OD8);//
									TIM3-&gt;CCR1 = speed *T_pwm;//ch1  pwm 
									TIM3-&gt;CCR2 = speed *0;//ch2 
                }
						else
								{
									GPIOA-&gt;ODR |=GPIO_ODR_OD8;//backgroud
									GPIOA-&gt;ODR &amp;=~(GPIO_ODR_OD5);
									TIM3-&gt;CCR1 = -speed * 0;//ch1
									TIM3-&gt;CCR2 = -speed * T_pwm;//ch2
								}
}

//Read count
int TIM4_Encoder_Read(void)
{

    return  (int)TIM4 -&gt;CNT;;           //Data type conversion
                             // Record the number of edge changes (a grid is recorded 4 times)
}




/****** Serial interrupt function******/
void USART2_IRQHandler(void)
{
	
	//Send part	
	if (USART2-&gt;SR &amp; USART_SR_TXE)//Txe register is empty Send data
{
if(buffer_size &gt; current_send_byte)
{
USART2-&gt;DR = buffer[current_send_byte];
current_send_byte++;
}
else
{
USART2-&gt;CR2 &amp;= ~USART_CR1_TXEIE;
current_send_byte = 0;
buffer_size = 0;
}
}

if(USART2-&gt;SR &amp; USART_SR_RXNE)//Receive interrupt indicator Trigger receive
{
//Receiving part//
Motor_Speed_Control(USART2-&gt;DR);
}
}


/***** Serial port sending function******/
void Send_buffer(uint8_t *buff, uint16_t count)
{
for(uint16_t i = 0; i &lt; count; i++)
{
buffer[buffer_size + i] = buff[i];
}
buffer_size += count;
USART2-&gt;CR1 |= USART_CR1_TXEIE;
}

/******Speed real-time transmission function*********/
void Init_tim10(uint16_t arr,uint16_t psc)
{
//OPEN TIM10
RCC-&gt;APB2ENR |=1&lt;&lt;17;
TIM10-&gt;CNT=0;//CLEAR
TIM10-&gt;PSC = psc;
TIM10-&gt;ARR = arr;
/*Allow update interrupt enable*/
TIM10-&gt;DIER |= 1&lt;&lt;0;
/*Enable basic timer interrupt*/
NVIC_EnableIRQ(TIM1_UP_TIM10_IRQn);
/*Turn on counter enable*/
TIM10-&gt;CR1 |= 1&lt;&lt;0;
}
void TIM1_UP_TIM10_IRQHandler(void)
{
TIM10-&gt;SR &amp;=~TIM_SR_UIF;
static uint8_t i=0;
if(++i==100) i=0;
int8_t s= TIM4_Encoder_Read();
buffer[0]='A';
buffer[1]=i;
buffer[2]=s;
if(1)
{
Send_buffer(buffer,3);
}
}

int main()
{

T_pwm=1000/100;
clock_set();
usart2_Init(USART_BAUDRATE);
init_TIM3_PWM(84-1,1000);//1khz	
TIM4_Encoder_Init(255,0);//255
Init_tim10(10000,84-1);
while(1)
{
}	
}

</code></pre>
<h3 id="simulation">Simulation</h3>
<p>Matlab block diagram is as follows<br>
<img src="https://liuxuejun123.github.io//post-images/1588174118895.PNG" alt="" loading="lazy"><br>
Proteus block diagram is as follows:<br>
<img src="https://liuxuejun123.github.io//post-images/1588174155802.png" alt="" loading="lazy"><br>
The upper virtual terminal displays the output data, and the lower virtual terminal actually inputs<br>
<img src="https://liuxuejun123.github.io//post-images/1588174192302.png" alt="" loading="lazy"><br>
<img src="https://liuxuejun123.github.io//post-images/1588174202296.png" alt="" loading="lazy"><br>
<img src="https://liuxuejun123.github.io//post-images/1588174210262.png" alt="" loading="lazy"><br>
<img src="https://liuxuejun123.github.io//post-images/1588174223917.PNG" alt="" loading="lazy"></p>
<h2 id="conclusion">Conclusion</h2>
<p>Through this experiment, I mainly learned to use the stm32 output PWM to control the motor, use the data received by the serial port to modify the PWM duty cycle, thereby changing the speed of the motor, and use the encoder function of stm32 to carry out the speed of the motor. Detect and send through the serial port.</p>

							</div>
	<div class="wow bounceInDown vt-post-tags">
 
					</div>						
<nav class="navigation3 post-navigation3" role="navigation">
		
		<div class="nav-links3">
      
		<div class="wow bounceInLeft nav-previous3"><a href="https://liuxuejun123.github.io/post/stm32-kong-zhi-si-fu-dian-ji/" rel="prev"> STM32 控制伺服电机</a></div>
		 
		 
		<div class="wow bounceInRight nav-next3"><a href="https://liuxuejun123.github.io/post/stm-32-ding-shi-qi-de-shi-yong/" rel="next"> STM 32 定时器的使用</a></div>
		
		</div>
	</nav>
	<div class="wow rollIn author-info" style="visibility: visible; animation-name: rollIn;">
	<div class="author-avatar pull-left"><img src="https://liuxuejun123.github.io//images/avatar.png" ></div>
 
	<div class="author-description"><div class="author-title"><div class="author-link" rel="author">INNovationlxj</div></div>


	<p class="author-bio">只有足够努力，才能看起来毫不费力</p></div></div>
	
		</div>
		
 
		
</article>

<div id="marlin_lite_about_widget-2" class="wow bounceInUp widget marlin_lite_about_widget" data-wow-delay="0.1s">
		
        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '02fde2256e86a11523ed',
    clientSecret: '3487de5da242c0c8dcd7abad1ae855843fe43be8',
    repo: 'LiuXuejun123.github.io',
    owner: 'LiuXuejun123 ',
    admin: ['LiuXuejun123 '],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          
          
        
		<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://liuxuejun123.github.io//media/scripts/Valine.min.js'></script>

<div class="comment"></div>
<script>
        new Valine({
            // AV 对象来自上面引入av-min.js(老司机们不要开车➳♡゛扎心了老铁)
            av: AV, 
            el: '.comment',
            lang: 'zh-cn',
            
            admin_email:'liuxuejun0855@163.com',
            
            
      emoticon_list: ["吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],
     	
      	
          
        });
    </script> 


   
  
 

		</div>

			</div>
			


<div class="tocc col l3 hide-on-med-and-down">
	
        <div class="toc-widget">
			
            <div class="toc-title"></div>
			
            <div id="toc-content">
			
			
			</div>
        </div>
    </div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.5.0/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '.entry-summary',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('.entry-summary').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>										 

 
       


			</div>
		</div>

		
		 	<footer id="colophon" class="site-footer">

			<div class="container">
	
				<div class="copyright">Powered by 
<a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
<br><br>
Copyright 2020 &copy 
<a href="https://twitter.com/mei_samson" target="_blank">
<span style="color:blue">Liuxuejun</span></a>
<br><br>
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="blank"
<span style="color:orange">本博客采用 CC BY-NC-SA 4.0 进行许可</span></a><br>Theme:   <a href="https://github.com/shanbufun/gridea-theme-pan" target="_blank" title="Pan"><span>Pan</span></a>.  by <a href="https://shanbu.fun/" target="_blank"  title="山卜方" >Shanbufun</a></div>		
			</div>
		
		</footer>

</div>

<script src="https://cdn.bootcss.com/fitvids/1.2.0/jquery.fitvids.min.js"></script>
<script type='text/javascript' src='https://liuxuejun123.github.io//media/scripts/marlin-scripts.js'></script>
 <script src="//tokinx.github.io/lately/lately.min.js"></script>
  <script>jQuery(document).ready(function(){$.lately({'target':'.lately-a,.lately-b,.lately-c'})});</script>
  <style type="text/css">a.back_to_top {
    text-decoration: none;
    position: fixed;
    bottom: 40px;
    right: 30px;
    background: #f0f0f0;
    height: 40px;
    width: 40px;
    border-radius: 50%;
    line-height: 36px;
    font-size: 18px;
    text-align: center;
    transition-duration: .5s;
    transition-propety: background-color;
    display: none;
}

a.back_to_top span {
    color: #888;
}

a.back_to_top:hover {
    cursor: pointer;
    background: #dfdfdf;
}

a.back_to_top:hover span {
    color: #555;
}

@media print, screen and (max-width: 580px) {
    .back_to_top {
        display: none !important;
    }
}



</style><a id="back_to_top" href="#" class="back_to_top"><span><i class="iconfont icon-xiangshang"></i></span>
</a>


<script>$(document).ready((function(_this) {
  return function() {
    var bt;
    bt = $('#back_to_top');
    if ($(document).width() > 480) {
      $(window).scroll(function() {
        var st;
        st = $(window).scrollTop();
        if (st > 30) {
          return bt.css('display', 'block');
        } else {
          return bt.css('display', 'none');
        }
      });
      return bt.click(function() {
        $('body,html').animate({
          scrollTop: 0
        }, 800);
        return false;
      });
    }
  };
})(this));
</script>

		<script data-no-instant>
    (function ($) {
        $.extend({
            adamsOverload: function () {
                $('.navigation:eq(0)').remove();
                $("").attr("rel" , "external");
                $("a[rel='external'],a[rel='external nofollow']").attr("target","_blank");
                $("a.vi").attr("rel" , "");
                $.viewImage({
                    'target'  : 'img',
                    'exclude' : '.vsmile-icons img,.gallery img',
                    'delay'   : 300
                });
                $.lately({
                    'target' : '.commentmetadata a,.infos time,.post-list time'
                });
                prettyPrint();
                
                $('ul.links li a').each(function(){
                    if($(this).parent().find('.bg').length==0){
                        $(this).parent().append('<!---<div class="bg" style="background-image:url(https://c3.glgoo.top/s2/favicons?domain='+$(this).attr("href")+')"></div>--->')
                    }
                });
            }
        });
    })(jQuery);
    jQuery.adamsOverload();
</script>

</body>
</html>
