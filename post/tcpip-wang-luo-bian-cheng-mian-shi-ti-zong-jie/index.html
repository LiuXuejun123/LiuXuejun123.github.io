<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Liu Xuejun&#39;s Blog</title>
<meta name="description" content="念念不忘，必有回响" />
<link rel="shortcut icon" href="https://liuxuejun123.github.io/favicon.ico?v=1625151154278">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://liuxuejun123.github.io/styles/main.css">
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>


  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://liuxuejun123.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://liuxuejun123.github.io/images/avatar.png?v=1625151154278" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">Liu Xuejun&#39;s Blog</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#1-%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">1、网络体系结构</a></li>
<li><a href="#2-tcp%E5%92%8Cudp%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">2、TCP和UDP有什么区别</a></li>
<li><a href="#3-%E7%BC%96%E5%86%99socket%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E6%AD%A5%E9%AA%A4">3、编写socket套接字的步骤</a></li>
<li><a href="#4-tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%BB%A5%E5%8F%8A%E5%90%84%E4%B8%AA%E7%8A%B6%E6%80%81%E7%9A%84%E4%BD%9C%E7%94%A8">4、TCP三次握手和四次挥手，以及各个状态的作用</a></li>
<li><a href="#5-http%E5%8D%8F%E8%AE%AE%E5%92%8Ctcp%E7%9A%84%E5%8C%BA%E5%88%AB">5、Http协议和TCP的区别</a></li>
<li><a href="#6-%E5%90%8C%E6%AD%A5io%E5%92%8C%E5%BC%82%E6%AD%A5io%E7%9A%84%E5%8C%BA%E5%88%AB">6、同步IO和异步IO的区别</a></li>
<li><a href="#7-%E4%BB%80%E4%B9%88%E6%98%AFiocp">7、什么是IOCP</a></li>
<li><a href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97socket%E6%B5%81%E5%A5%97%E6%8E%A5%E5%AD%97sock_stream%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE">8、什么是网络套接字(Socket)?流套接字(SOCK_STREAM)基于什么协议</a></li>
<li><a href="#9-ip%E9%A6%96%E9%83%A8-tcp%E9%A6%96%E9%83%A8-udp%E9%A6%96%E9%83%A8-%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%A6%96%E9%83%A8">9、IP首部、TCP首部、UDP首部、以太网首部</a></li>
<li><a href="#10-tcp%E5%92%8Cudp%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">10、TCP和UDP的应用场景</a></li>
<li><a href="#11-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E7%9A%84udp">11、如何实现可靠的UDP</a></li>
<li><a href="#12-%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8Etcp%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB%E8%BF%87%E7%A8%8B">12、详细说明TCP状态迁移过程</a></li>
<li><a href="#13-2msl%E6%98%AF%E4%BB%80%E4%B9%88%E7%8A%B6%E6%80%81%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">13、2MSL是什么状态？作用是什么</a></li>
<li><a href="#14-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%88%96%E8%80%85%E5%9B%9B%E6%AC%A1">14、三次握手为什么不是两次或者四次</a></li>
<li><a href="#15-tcp%E9%87%8D%E5%8F%91%E6%9C%BA%E5%88%B6">15、TCP重发机制</a></li>
<li><a href="#16-%E8%AF%B4%E8%AF%B4nagle%E7%AE%97%E6%B3%95">16、说说Nagle算法</a></li>
<li><a href="#17-tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">17、TCP拥塞控制</a></li>
<li><a href="#18-tcp%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">18、TCP的滑动窗口</a></li>
<li><a href="#19-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B">19、域名解析的过程</a></li>
<li><a href="#20-arp%E7%9A%84%E6%9C%BA%E5%88%B6">20、ARP的机制</a></li>
<li><a href="#21-rarp%E7%9A%84%E5%AE%9E%E7%8E%B0">21、RARP的实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="\achieve" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by 
<a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
<br><br>
Copyright 2020 &copy 
<a href="https://twitter.com/mei_samson" target="_blank">
<span style="color:blue">Liuxuejun</span></a>
<br><br>
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="blank"
<span style="color:orange">本博客采用 CC BY-NC-SA 4.0 进行许可</span></a></div>
    <a class="rss" href="https://liuxuejun123.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">TCP/IP网络编程面试题总结</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2021-06-28 / 17 min read
        </div>
        
        <div class="post-content yue">
          <h4 id="1-网络体系结构">1、网络体系结构</h4>
<p>网络体系结构（network architecture）：是计算机之间相互通信的层次，以及各层中的协议和层次之间接口的集合</p>
<p>特点：适用性、特指性、抽象性、过程性</p>
<h4 id="2-tcp和udp有什么区别">2、TCP和UDP有什么区别</h4>
<p>1、连接方面区别</p>
<p>TCP面向连接（如打电话要先拨号建立连接）。</p>
<p>UDP是无连接的，即发送数据之前不需要建立连接。</p>
<p>2、安全方面的区别</p>
<p>TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。</p>
<p>UDP尽最大努力交付，即不保证可靠交付。</p>
<p>3、传输效率的区别</p>
<p>TCP传输效率相对较低。</p>
<p>UDP传输效率高，适用于对高速传输和实时性有较高的通信或广播通信。</p>
<p>4、连接对象数量的区别</p>
<p>TCP连接只能是点到点、一对一的。</p>
<p>UDP支持一对一，一对多，多对一和多对多的交互通信。</p>
<h4 id="3-编写socket套接字的步骤">3、编写socket套接字的步骤</h4>
<p>服务器端程序的编写步骤：</p>
<p>第一步：调用socket()函数创建一个用于通信的套接字。</p>
<p>第二步：给已经创建的套接字绑定一个端口号，这一般通过设置网络套接口地址和调用bind()函数来实现。</p>
<p>第三步：调用listen()函数使套接字成为一个监听套接字。</p>
<p>第四步：调用accept()函数来接受客户端的连接，这是就可以和客户端通信了。</p>
<p>第五步：处理客户端的连接请求。</p>
<p>第六步：终止连接。</p>
<p>客户端程序编写步骤：、</p>
<p>第一步：调用socket()函数创建一个用于通信的套接字。</p>
<p>第二步：通过设置套接字地址结构，说明客户端与之通信的服务器的IP地址和端口号。</p>
<p>第三步：调用connect()函数来建立与服务器的连接。</p>
<p>第四步：调用读写函数发送或者接收数据。</p>
<p>第五步：终止连接。</p>
<h4 id="4-tcp三次握手和四次挥手以及各个状态的作用">4、TCP三次握手和四次挥手，以及各个状态的作用</h4>
<p><strong>三次握手</strong></p>
<p>第一次握手：主机A发送位码为syn＝1,随机产生seq number=10001的数据包到服务器，主机B由SYN=1知道，A要求建立联机，此时状态为SYN_SENT；<br>
第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=20001的包，此时状态由LISTEN变为SYN_RECV；<br>
第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功，双方状态ESTABLISHED</p>
<p><strong>四次挥手</strong></p>
<p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。<br>
第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。<br>
第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。<br>
第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。<br>
<strong>各个状态的作用</strong></p>
<p>LISTEN：侦听来自远方的TCP端口的连接请求</p>
<p>SYN-SENT：再发送连接请求后等待匹配的连接请求（客户端）</p>
<p>SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认（服务器）</p>
<p>ESTABLISHED：代表一个打开的连接</p>
<p>FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认</p>
<p>FIN-WAIT-2：从远程TCP等待连接中断请求</p>
<p>CLOSE-WAIT：等待从本地用户发来的连接中断请求</p>
<p>CLOSING：等待远程TCP对连接中断的确认</p>
<p>LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认</p>
<p>TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认</p>
<p>CLOSED：没有任何连接状态</p>
<h4 id="5-http协议和tcp的区别">5、Http协议和TCP的区别</h4>
<p>TCP协议对应于传输层，而HTTP协议对应于应用层，从本质上来说，二者没有可比性。</p>
<p>1，http对应于应用层</p>
<p>2，Tcp协议对应于传输层</p>
<p>3，http协议是在Tcp协议之上建立的，http在发起请求时通过tcp协议建立起连接服务器的通道，请求结束后，立即断开tcp连接</p>
<p>说明：从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p>
<p>4，Http是无状态的短连接，而TCP是有状态的长连接</p>
<h4 id="6-同步io和异步io的区别">6、同步IO和异步IO的区别</h4>
<p>数据拷贝的时候进程是否阻塞</p>
<h4 id="7-什么是iocp">7、什么是IOCP</h4>
<p>中文译作IO完成端口，他是一个异步I/O操作的API，他可以高效的将I/O事件通知给我们的应用程序，拿游戏项目来说，就是客户端或者服务器。</p>
<h4 id="8-什么是网络套接字socket流套接字sock_stream基于什么协议">8、什么是网络套接字(Socket)?流套接字(SOCK_STREAM)基于什么协议</h4>
<p>套接字，是支持<a href="https://baike.baidu.com/item/TCP%2FIP">TCP/IP</a>的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1">网络通信</a>的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>
<p>流套接字之所以能够实现可靠的数据服务，原因在于其使用了传输控制协议，即  TCP  （The Transmission Control Protocol）协议。</p>
<h4 id="9-ip首部-tcp首部-udp首部-以太网首部">9、IP首部、TCP首部、UDP首部、以太网首部</h4>
<p><strong>IP首部</strong></p>
<p>版本：L3协议版本号，IPv4或IPv6</p>
<p>首部长度：单位为4字节</p>
<p>协议：L4协议类型</p>
<p>TTL生存时间字段设置了数据报可以经过的最多路由器数。一旦经过一个处理它的路由器，它的值就减1。当该字段值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。</p>
<p><strong>TCP首部</strong></p>
<p>源端口号、目的端口号：用于寻找发送端和接收端应用进程。</p>
<p>32位序号：用于标识从TCP发端向TCP收端发送的数据字节流，表示在这个报文段中的第一个数据字节。</p>
<p>确认号包含发送确认的一端所期望收到的下一个包的序列号，只有ACK标志为1时，确认号字段才有效。</p>
<p>一旦一上连接建立起来，ACK标志总是被设置为1。</p>
<p>16位窗口大小：最大值为2<sup>16-1（MTU：最大传输单元，以太网最大传输单元为1518字节，但以太网可以传送一个长达65535字节(2</sup>16-1)的IP数据包，链路层会对其进行分片）。</p>
<p>4位首部长度：单位为32bit，包含选项字段。</p>
<p>TCP为应用层提供全双工服务，这意味着连接的每一端必须保持每个方向上的传输数据序列号和确认号。</p>
<p>URG：紧急指针有效</p>
<p>ACK：确认号有效</p>
<p>PSH：接收方应该尽快将这个报文段交给应用层</p>
<p>RST：重建连接</p>
<p>SYN：同步序号用来发起一个连接</p>
<p>FIN：发端完成发送任务</p>
<p><strong>UDP首部</strong></p>
<p>16位UDP长度：包含头部和数据部分</p>
<p>16位UDP检验和：覆盖UDP首部和UDP数据</p>
<p>UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算检验和而设置的，伪首部包含IP首部中的一些字段。</p>
<p>TCP有超时重传机制，UDP没有。</p>
<p><strong>以太网首部</strong>？？？</p>
<h4 id="10-tcp和udp的应用场景">10、TCP和UDP的应用场景</h4>
<p><strong>UDP</strong>的应用场景：即时通信。面向数据报方式；网络数据大多为短消息；拥有大量客户端；对数据安全性无特殊要求；网络负担重但对响应速度要求高的场景。eg: IP电话、实时视频会议等。</p>
<p><strong>TCP</strong>的应用场景：对数据准确性要求高，速度可以相对较慢的。eg: 文件传输、邮件的发送与接收等</p>
<h4 id="11-如何实现可靠的udp">11、如何实现可靠的UDP</h4>
<p>​    最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p>
<ul>
<li>1、添加seq/ack机制，确保数据发送到对端</li>
<li>2、添加发送和接收缓冲区，主要是用户超时重传。</li>
<li>3、添加超时重传机制。</li>
</ul>
<h4 id="12-详细说明tcp状态迁移过程">12、详细说明TCP状态迁移过程</h4>
<p>？？？？</p>
<h4 id="13-2msl是什么状态作用是什么">13、2MSL是什么状态？作用是什么</h4>
<p>2MSL是TIME_WAIT状态</p>
<p>作用：1.主动发起终结端需要保持状态，防止FIN丢失，需要A端重新发送FIN包。</p>
<p>​           2. 2MSL的时间里，如果出现重连结的tcp连接，那么之前的包就会丢失。</p>
<h4 id="14-三次握手为什么不是两次或者四次">14、三次握手为什么不是两次或者四次</h4>
<p>三次握手的目的：是为了确认双方都有收发数据的能力。<br>
第一次： A-&gt;B，证明A有发消息的能力。<br>
第二次： -&gt;B &amp;&amp; B-&gt;A，证明B有收消息，并且有发消息的能力。<br>
第三次： A-&gt;B，证明A有收消息的能力。<br>
二次握手达不到目的，四次多余</p>
<h4 id="15-tcp重发机制">15、TCP重发机制</h4>
<ol>
<li>滑动窗口机制,确立收发的边界,能让发送方知道已经发送了多少(已确认)、尚未确认的字节数、尚待发送的字节数；让接收方知道(已经确认收到的字节数)</li>
<li>超时重传,tcp每发送一个报文段,就设置一次计时器,重传时间到但还没收到确认,就重传这一报文段,这个时间是加权平均的往返时间</li>
<li>选择重传，用于对传输出错的序列进行重传,如果中间有顺序的包丢了,接收窗口发送确认号的时候,会发丢之前的ack号,选择重发的包序号,选择确认</li>
</ol>
<h4 id="16-说说nagle算法">16、说说Nagle算法</h4>
<p>是为了减少广域网的小分组数目，从而减小网络拥塞的出现；</p>
<p>该算法要求一个tcp连接上最多只能有一个未被确认的未完成的小分组，在该分组ack到达之前不能发送其他的小分组，tcp需要收集这些少量的分组，并在ack到来时以一个分组的方式发送出去；其中小分组的定义是小于MSS的任何分组；</p>
<p>该算法的优越之处在于它是自适应的，确认到达的越快，数据也就发哦送的越快；而在希望减少微小分组数目的低速广域网上，则会发送更少的分组；</p>
<h4 id="17-tcp拥塞控制">17、TCP拥塞控制</h4>
<p>1、产生的原因</p>
<p>单纯的增加网络资源无法解决问题<br>
例如：把结点的存储空间扩大，更换更高速率的链路，提高结点处理机的运算速度，不仅不能解决问题，而且可能使网络性能更坏。<br>
原因：网络拥塞是许多因素引起的，单纯的解决一个可能会使上述情况得到一些缓解，但是会把拥塞转移到其他地方。<br>
扩大结点存储空间——&gt;由于输出链路的容量和处理机的速度并未提高，增大排队等待时间，超时重传，浪费资源。<br>
更换更高速率的链路——&gt;可能会缓解，有可能造成各部分不匹配。<br>
2、作用</p>
<p>防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载，是一个全局性的过程。</p>
<p>3、拥塞的标志</p>
<p>重传计时器超时<br>
接收到三个重复确认</p>
<h4 id="18-tcp的滑动窗口">18、TCP的滑动窗口</h4>
<p>1、概述</p>
<p>滑动窗口实现了TCP流控制。首先明确滑动窗口的范畴：TCP是双工的协议，会话的双方都可以同时接收和发送数据。TCP会话的双方都各自维护一个发送窗口和一个接收窗口。各自的接收窗口大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。各自的发送窗口则要求取决于对端通告的接收窗口，要求相同。</p>
<p>滑动窗口解决的是流量控制的的问题，就是如果接收端和发送端对数据包的处理速度不同，如何让双方达成一致。接收端的缓存传输数据给应用层，但这个过程不一定是即时的，如果发送速度太快，会出现接收端数据overflow，流量控制解决的是这个问题</p>
<p>2、窗口的概念</p>
<p>发送方的发送缓存内的数据都可以被分为4类:</p>
<p>a.已发送，已收到ACK</p>
<p>b.已发送，未收到ACK</p>
<p>c.未发送，但允许发送</p>
<p>d.未发送，但不允许发送</p>
<p>其中类型2和3都属于发送窗口。</p>
<p>接收方的缓存数据分为3类：</p>
<p>a.已接收</p>
<p>b.未接收但准备接收</p>
<p>c.未接收而且不准备接收</p>
<p>其中类型2属于接收窗口。</p>
<p>窗口大小代表了设备一次能从对端处理多少数据，之后再传给应用层。缓存传给应用层的数据不能是乱序的，窗口机制保证了这一点。现实中，应用层可能无法立刻从缓存中读取数据。<br>
3、滑动机制</p>
<p>a.发送窗口只有收到发送窗口内字节的ACK确认，才会移动发送窗口的左边界</p>
<p>b.接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不会对后续字节确认，以此确保对端会对这些数据重传。</p>
<p>c.遵循快速重传、累计确认、选择确认等规则</p>
<p>d.发送方发的window size=8192；就是接收端最多发送8192字节，这个8192一般就是发送方接收缓存的大小。</p>
<h4 id="19-域名解析的过程">19、域名解析的过程</h4>
<p>当一个用户在地址栏输入www.taobao.com时，DNS解析有大致十个过程，如下：</p>
<p>\1. 浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址，如果有，解析结束。同时域名被缓存的时间也可通过TTL属性来设置。</p>
<p>\2.  如果浏览器缓存中没有（专业点叫还没命中），浏览器会检查操作系统缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在windows中可通过c盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的ip地址，那浏览器会首先使用这个ip地址。</p>
<p>但是这种操作系统级别的域名解析规程也被很多黑客利用，通过修改你的hosts文件里的内容把特定的域名解析到他指定的ip地址上，造成所谓的域名劫持。所以在windows7中将hosts文件设置成了readonly，防止被恶意篡改。</p>
<p>\3.  如果至此还没有命中域名，才会真正的请求本地域名服务器（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。</p>
<p>\4. 如果LDNS仍然没有命中，就直接跳到Root Server 域名服务器请求解析</p>
<p>\5. 根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址</p>
<p>\6. 此时LDNS再发送请求给上一步返回的gTLD</p>
<p>\7. 接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器</p>
<p>\8. Name Server根据映射关系表找到目标ip，返回给LDNS</p>
<p>\9. LDNS缓存这个域名和对应的ip</p>
<p>\10. LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束</p>
<h4 id="20-arp的机制">20、ARP的机制</h4>
<p>ARP协议是“Address Resolution  Protocol”（地址解析协议）的缩写。在局域网中，网络中实际传输的是“帧”，帧里面是有目标主机的MAC地址的。在以太网中，一个主机和另一个主机进行直接通信，必须要知道目标主机的MAC地址。但这个目标MAC地址是如何获得的呢？它就是通过地址解析协议获得的。所谓“地址解析”就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。</p>
<h4 id="21-rarp的实现">21、RARP的实现</h4>
<p>RARP工作原理：</p>
<p>(1)网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。PC1从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求RARP服务器回复该PC的IP地址。</p>
<p>(2)RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给PC1。</p>
<p>(3)PC1收到RARP回应后，就使用得到的IP地址进行通讯。</p>
<p>RARP的实现是在数据链路层实现的，</p>

        </div>

        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://liuxuejun123.github.io/post/wang-pan-xiang-mu/">
                <h3 class="post-title">
                  <i class="ri-arrow-left-line"></i>
                  网盘项目
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://liuxuejun123.github.io/post/cji-chu-zhi-shi-mian-shi-ti-zong-jie/">
                <h3 class="post-title">
                  C++基础知识面试题总结
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>
			<div id="vcomments"></div>
			<script>
			new Valine({
			el: '#vcomments',
			appId: '7PkqecRcjgS1uaF60SMWxDMH-gzGzoHsz',
			appKey: 'Vb5bQCHJavyHDCk3mor2nHkj'
			})
			</script>
        

      </div>
    </div>

    <script src="https://liuxuejun123.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
